动态规划的使用环境：
    １：最优化原理，子结构也是最优的
    ２：无后效性，也就是说给定某个阶段，它以前阶段的状态无法直接影响它未来的决策，只能根据当前状态决定
    ３：子问题的重叠性，其实就是空间换时间的算法，空间复杂度会大于其他算法


动态规划经典案例：
/**
 * 有n阶台阶，一个人每次上一级或者两级，问有多少种方法走完n阶台阶
 */
public static void main(String[] args) {
    //表示n阶台阶
    int n;
    System.out.println(find(n));
}
public static int find(n) {
    if(n == 1 || n == 2) {
        return n;
    }else｛
        return find(n-1) + find(n-2);
    ｝
}


/**
 * 两个字符串的最长公共子序列
 */
 
 
/**
 * 矩阵求最长路径(限定条件，只能向右走或者向下走)
 */
